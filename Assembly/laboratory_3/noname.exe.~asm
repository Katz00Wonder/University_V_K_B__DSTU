.model small
.stack 100h

.data
; Массив слов (16-битных значений)
numbers dw 5, -3, 8, 1, -7, 12, 0, 4, -2, 9
count equ ($ - numbers) / 2  ; Количество элементов в массиве

; Сообщения
msg_positive db 'Positive numbers found: $'
msg_min db 0Dh, 0Ah, 'Minimum positive number: $'
msg_none db 0Dh, 0Ah, 'No positive numbers found$'
msg_space db ' $'

min_value dw ?        ; Для хранения минимального положительного числа
found_flag db 0       ; Флаг: найдены ли положительные числа

.code
main proc
mov ax, @data
mov ds, ax

; Инициализация
mov cx, count         ; Загружаем количество элементов
mov si, offset numbers ; Указатель на начало массива
mov found_flag, 0     ; Сбрасываем флаг

; Поиск первого положительного числа для инициализации min_value
mov bx, 0FFFFh        ; Начальное значение (максимальное возможное)

find_first_positive:
mov ax, [si]          ; Загружаем текущее число
test ax, ax           ; Проверяем знак
jle next_element      ; Если <= 0, пропускаем

; Нашли первое положительное число
mov bx, ax           ; Инициализируем минимум
mov min_value, ax
mov found_flag, 1    ; Устанавливаем флаг
jmp continue_search

next_element:
add si, 2            ; Переходим к следующему элементу
loop find_first_positive

; Если не найдено положительных чисел
cmp found_flag, 0
je no_positive

continue_search:
; Продолжаем поиск минимального положительного числа
mov cx, count - 1    ; Оставшиеся элементы
add si, 2            ; Переходим к следующему элементу

search_loop:
mov ax, [si]         ; Загружаем текущее число

; Проверяем, положительное ли число
test ax, ax
jle skip_negative    ; Если <= 0, пропускаем

; Сравниваем с текущим минимумом
cmp ax, bx
jge skip_positive    ; Если больше или равно, пропускаем

; Нашли новый минимум
mov bx, ax
mov min_value, ax

skip_positive:
mov found_flag, 1    ; Устанавливаем флаг, что нашли положительное

skip_negative:
add si, 2            ; Переходим к следующему элементу
loop search_loop

; Проверяем, были ли найдены положительные числа
cmp found_flag, 0
je no_positive

; Вывод результатов
call display_results
jmp exit_program

no_positive:
; Вывод сообщения об отсутствии положительных чисел
mov ah, 09h
lea dx, msg_none
int 21h
jmp exit_program

exit_program:
mov ax, 4C00h
int 21h
main endp

; Процедура для вывода результатов
display_results proc
; Вывод заголовка
mov ah, 09h
lea dx, msg_positive
int 21h

; Вывод всех положительных чисел
mov cx, count
mov si, offset numbers

print_loop:
mov ax, [si]
test ax, ax
jle skip_print

; Вывод положительного числа
call print_number
mov ah, 09h
lea dx, msg_space
int 21h

skip_print:
add si, 2
loop print_loop

; Вывод минимального положительного числа
mov ah, 09h
lea dx, msg_min
int 21h

mov ax, min_value
call print_number

ret
display_results endp

; Процедура для вывода числа (16-битное)
print_number proc
push ax
push bx
push cx
push dx

mov bx, 10          ; Основание системы счисления
xor cx, cx          ; Счетчик цифр

; Проверка знака
test ax, ax
jns convert_loop
neg ax              ; Если отрицательное, делаем положительным
push ax
mov dl, '-'
mov ah, 02h
int 21h
pop ax

convert_loop:
xor dx, dx
div bx              ; Делим AX на 10
push dx             ; Сохраняем остаток (цифру)
inc cx              ; Увеличиваем счетчик цифр
test ax, ax
jnz convert_loop

print_digits:
pop dx              ; Извлекаем цифру
add dl, '0'         ; Преобразуем в символ
mov ah, 02h         ; Вывод символа
int 21h
loop print_digits

pop dx
pop cx
pop bx
pop ax
ret
print_number endp

end main

