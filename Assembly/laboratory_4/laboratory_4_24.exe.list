EMU8086 GENERATED LISTING. MACHINE CODE <- SOURCE.
 
laboratory_4_24.exe -- emu8086 assembler version: 4.08  
 
[ 17.09.2025  --  14:34:21 ] 
 
===================================================================================================
[LINE]     LOC: MACHINE CODE                          SOURCE
===================================================================================================
 
[   1]        :                                       .model small
[   2]        :                                       .stack 100h
[   3]        :                                       
[   4]        :                                       .data
[   5]        :                                       ; Массив из 6 байт
[   6]    0100: F0 07 3F 01 FF 00                     byte_array db 0F0h, 07h, 3Fh, 01h, 0FFh, 00h
[   7]        :                                       array_size equ 6
[   8]        :                                       
[   9]        :                                       ; Сообщения
[  10]    0106: 42 79 74 65 73 20 77 69 74 68 20 3C   msg_result db 'Bytes with <= 3 ones: $'
                3D 20 33 20 6F 6E 65 73 3A 20 24    
[  11]    011D: 0D 0A 43 6F 75 6E 74 3A 20 24         msg_count db 0Dh, 0Ah, 'Count: $'
[  12]    0127: 0D 0A 42 69 6E 61 72 79 3A 20 24      msg_binary db 0Dh, 0Ah, 'Binary: $'
[  13]    0132: 20 24                                 msg_space db ' $'
[  14]        :                                       
[  15]    0134: 00                                    count db 0           ; Счетчик байтов
[  16]    0135: 00                                    temp db ?            ; Временная переменная
[  17]        :                                       
[  18]        :                                       .code
[  19]    0140:                                       main proc
[  20]    0140: B8 10 00                              mov ax, @data
[  21]    0143: 8E D8                                 mov ds, ax
[  22]        :                                       
[  23]        :                                       ; Инициализация
[  24]    0145: B9 06 00                              mov cx, array_size   ; Количество элементов
[  25]    0148: BE 00 00                              mov si, offset byte_array ; Указатель на массив
[  26]    014B: C6 06 34 00 00                        mov count, 0         ; Обнуляем счетчик
[  27]        :                                       
[  28]        :                                       ; Вывод заголовка
[  29]    0150: B4 09                                 mov ah, 09h
[  30]    0152: BA 06 00                              lea dx, msg_result
[  31]    0155: CD 21                                 int 21h
[  32]        :                                       
[  33]    0157:                                       process_loop:
[  34]    0157: 8A 04                                 mov al, [si]         ; Загружаем текущий байт
[  35]    0159: A2 35 00                              mov temp, al         ; Сохраняем для вывода
[  36]        :                                       
[  37]        :                                       ; Подсчет количества единиц в байте
[  38]    015C: B3 00                                 mov bl, 0            ; Счетчик единиц
[  39]    015E: B6 08                                 mov dh, 8            ; Количество битов для проверки
[  40]        :                                       
[  41]    0160:                                       count_ones:
[  42]    0160: A8 01                                 test al, 1           ; Проверяем младший бит
[  43]    0162: 74 02                                 jz bit_zero          ; Если 0, пропускаем
[  44]        :                                       
[  45]    0164: FE C3                                 inc bl               ; Увеличиваем счетчик единиц
[  46]        :                                       
[  47]    0166:                                       bit_zero:
[  48]    0166: D0 E8                                 shr al, 1            ; Сдвигаем вправо для проверки следующего бита
[  49]    0168: FE CE                                 dec dh               ; Уменьшаем счетчик битов
[  50]    016A: 75 F4                                 jnz count_ones       ; Продолжаем, пока не проверим все биты
[  51]        :                                       
[  52]        :                                       ; Проверяем, не превышает ли количество единиц 3
[  53]    016C: 80 FB 03                              cmp bl, 3
[  54]    016F: 77 0E                                 ja skip_count        ; Если больше 3, пропускаем
[  55]        :                                       
[  56]        :                                       ; Увеличиваем общий счетчик
[  57]    0171: FE 06 34 00                           inc count
[  58]        :                                       
[  59]        :                                       ; Вывод текущего байта в двоичном виде
[  60]    0175: E8 1C 00                              call print_binary_byte
[  61]    0178: B4 09                                 mov ah, 09h
[  62]    017A: BA 32 00                              lea dx, msg_space
[  63]    017D: CD 21                                 int 21h
[  64]        :                                       
[  65]    017F:                                       skip_count:
[  66]    017F: 46                                    inc si               ; Переходим к следующему байту
[  67]    0180: E2 D5                                 loop process_loop
[  68]        :                                       
[  69]        :                                       ; Вывод результата
[  70]    0182: B4 09                                 mov ah, 09h
[  71]    0184: BA 1D 00                              lea dx, msg_count
[  72]    0187: CD 21                                 int 21h
[  73]        :                                       
[  74]        :                                       ; Вывод количества
[  75]    0189: A0 34 00                              mov al, count
[  76]    018C: E8 27 00                              call print_number
[  77]        :                                       
[  78]        :                                       ; Завершение программы
[  79]    018F: B8 00 4C                              mov ax, 4C00h
[  80]    0192: CD 21                                 int 21h
[  81]        :                                       main endp
[  82]        :                                       
[  83]        :                                       ; Процедура для вывода байта в двоичном виде
[  84]    0194:                                       print_binary_byte proc
[  85]    0194: 50                                    push ax
[  86]    0195: 53                                    push bx
[  87]    0196: 51                                    push cx
[  88]    0197: 52                                    push dx
[  89]        :                                       
[  90]    0198: A0 35 00                              mov al, temp
[  91]    019B: B1 08                                 mov cl, 8            ; 8 битов для вывода
[  92]    019D: B5 00                                 mov ch, 0
[  93]        :                                       
[  94]    019F:                                       print_bits:
[  95]    019F: D0 C0                                 rol al, 1            ; Сдвигаем старший бит в CF
[  96]    01A1: 72 04                                 jc print_one
[  97]        :                                       
[  98]        :                                       ; Вывод '0'
[  99]    01A3: B2 30                                 mov dl, '0'
[ 100]    01A5: EB 02                                 jmp print_bit
[ 101]        :                                       
[ 102]    01A7:                                       print_one:
[ 103]        :                                       ; Вывод '1'
[ 104]    01A7: B2 31                                 mov dl, '1'
[ 105]        :                                       
[ 106]    01A9:                                       print_bit:
[ 107]    01A9: B4 02                                 mov ah, 02h
[ 108]    01AB: CD 21                                 int 21h
[ 109]        :                                       
[ 110]    01AD: FE C9                                 dec cl
[ 111]    01AF: 75 EE                                 jnz print_bits
[ 112]        :                                       
[ 113]    01B1: 5A                                    pop dx
[ 114]    01B2: 59                                    pop cx
[ 115]    01B3: 5B                                    pop bx
[ 116]    01B4: 58                                    pop ax
[ 117]    01B5: C3                                    ret
[ 118]        :                                       print_binary_byte endp
[ 119]        :                                       
[ 120]        :                                       ; Процедура для вывода числа (0-255)
[ 121]    01B6:                                       print_number proc
[ 122]    01B6: 50                                    push ax
[ 123]    01B7: 53                                    push bx
[ 124]    01B8: 51                                    push cx
[ 125]    01B9: 52                                    push dx
[ 126]        :                                       
[ 127]    01BA: B3 0A                                 mov bl, 10          ; Основание системы счисления
[ 128]    01BC: 33 C9                                 xor cx, cx          ; Счетчик цифр
[ 129]        :                                       
[ 130]        :                                       ; Преобразование числа в строку
[ 131]    01BE:                                       convert_loop:
[ 132]    01BE: 32 E4                                 xor ah, ah
[ 133]    01C0: F6 F3                                 div bl              ; Делим AL на 10
[ 134]    01C2: 8A D4                                 mov dl, ah          ; Остаток в DL
[ 135]    01C4: 52                                    push dx             ; Сохраняем цифру
[ 136]    01C5: 41                                    inc cx              ; Увеличиваем счетчик цифр
[ 137]    01C6: 84 C0                                 test al, al
[ 138]    01C8: 75 F4                                 jnz convert_loop
[ 139]        :                                       
[ 140]        :                                       ; Вывод цифр
[ 141]    01CA:                                       print_digits:
[ 142]    01CA: 5A                                    pop dx              ; Извлекаем цифру
[ 143]    01CB: 80 C2 30                              add dl, '0'         ; Преобразуем в символ
[ 144]    01CE: B4 02                                 mov ah, 02h         ; Вывод символа
[ 145]    01D0: CD 21                                 int 21h
[ 146]    01D2: E2 F6                                 loop print_digits
[ 147]        :                                       
[ 148]    01D4: 5A                                    pop dx
[ 149]    01D5: 59                                    pop cx
[ 150]    01D6: 5B                                    pop bx
[ 151]    01D7: 58                                    pop ax
[ 152]    01D8: C3                                    ret
[ 153]        :                                       print_number endp
[ 154]        :                                       
[ 155]        :                                       end main
[ 156]        :                                       
 
===================================================================================================
 
EXE HEADER - bytes from 0000 to 01FF inclusive.

0000: 4D      -   exe signature (M)
0001: 5A      -   exe signature (Z)
0002: D9      -   bytes on last page (l.byte)
0003: 01      -   bytes on last page (h.byte)
0004: 02      -   512 byte pages in file (l.byte)
0005: 00      -   512 byte pages in file (h.byte)
0006: 01      -   relocations (l.byte)
0007: 00      -   relocations (h.byte)
0008: 20      -   paragraphs in header (l.byte)
0009: 00      -   paragraphs in header (h.byte)
000A: 00      -   minimum memory (l.byte)
000B: 00      -   minimum memory (h.byte)
000C: FF      -   maximum memory (l.byte)
000D: FF      -   maximum memory (h.byte)
000E: 00      -   SS - stack segment (l.byte)
000F: 00      -   SS - stack segment (h.byte)
0010: 00      -   SP - stack pointer (l.byte)
0011: 01      -   SP - stack pointer (h.byte)
0012: 9F      -   check sum (l.byte)
0013: C4      -   check sum (h.byte)
0014: 00      -   IP - instruction pointer (l.byte)
0015: 00      -   IP - instruction pointer (h.byte)
0016: 14      -   CS - code segment (l.byte)
0017: 00      -   CS - code segment (h.byte)
0018: 1E      -   relocation table adress (l.byte)
0019: 00      -   relocation table adress (h.byte)
001A: 00      -   overlay number (l.byte)
001B: 00      -   overlay number (h.byte)
001C: 01      -   signature (l.byte)
001D: 00      -   signature (h.byte)
001E: 01      -   relocation table - offset inside segment (l.byte)
001F: 00      -   relocation table - offset inside segment (h.byte)
0020: 14      -   relocation table - segment anchor (l.byte)
0021: 00      -   relocation table - segment anchor (h.byte)
0022 to 01FF  -   reserved relocation area  (00) 




===================================================================================================
